/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    revision(body: GoodsRevisionDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/storage/revision";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRevision(_response);
        });
    }

    protected processRevision(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    supplies(body: GoodsSuppliesDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/storage/supplies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSupplies(_response);
        });
    }

    protected processSupplies(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    edit(body: EditGoodsListDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/storage/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    goods(  cancelToken?: CancelToken | undefined): Promise<GoodsItemDto[]> {
        let url_ = this.baseUrl + "/goods";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGoods(_response);
        });
    }

    protected processGoods(response: AxiosResponse): Promise<GoodsItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GoodsItemDto.fromJS(item));
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GoodsItemDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    close(id: number, cash: number, token?:string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/close/{id}/{cash}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cash === undefined || cash === null)
            throw new Error("The parameter 'cash' must be defined.");
        url_ = url_.replace("{cash}", encodeURIComponent("" + cash));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                Authorization: `Bearer ${token}`,
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClose(_response);
        });
    }

    protected processClose(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    change(oldPassword: string, password: string , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/change/{oldPassword}/{password}";
        if (oldPassword === undefined || oldPassword === null)
            throw new Error("The parameter 'oldPassword' must be defined.");
        url_ = url_.replace("{oldPassword}", encodeURIComponent("" + oldPassword));
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined.");
        url_ = url_.replace("{password}", encodeURIComponent("" + password));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChange(_response);
        });
    }

    protected processChange(response: AxiosResponse): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    signin(body: SignInDto | undefined , cancelToken?: CancelToken | undefined): Promise<UserInfoDto> {
        let url_ = this.baseUrl + "/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignin(_response);
        });
    }

    protected processSignin(response: AxiosResponse): Promise<UserInfoDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserInfoDto.fromJS(resultData200);
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserInfoDto>(<any>null);
    }

    /**
     * @return Success
     */
    signout(id: number , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/signout/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignout(_response);
        });
    }

    protected processSignout(response: AxiosResponse): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }
}

export class StatisticsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    full(id: number, day: Date , cancelToken?: CancelToken | undefined): Promise<ShiftSnapshotDto[]> {
        let url_ = this.baseUrl + "/sold_statistics_full/{id}/{day}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (day === undefined || day === null)
            throw new Error("The parameter 'day' must be defined.");
        url_ = url_.replace("{day}", encodeURIComponent(day ? "" + day.toJSON() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFull(_response);
        });
    }

    protected processFull(response: AxiosResponse): Promise<ShiftSnapshotDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShiftSnapshotDto.fromJS(item));
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShiftSnapshotDto[]>(<any>null);
    }
}

export class CloseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    other(targetUserId: number, cash: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/close_other/{targetUserId}/{cash}";
        if (targetUserId === undefined || targetUserId === null)
            throw new Error("The parameter 'targetUserId' must be defined.");
        url_ = url_.replace("{targetUserId}", encodeURIComponent("" + targetUserId));
        if (cash === undefined || cash === null)
            throw new Error("The parameter 'cash' must be defined.");
        url_ = url_.replace("{cash}", encodeURIComponent("" + cash));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOther(_response);
        });
    }

    protected processOther(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class InitClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    shift(id: number, token?:string | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/init_shift/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                Authorization: `Bearer ${token}`,
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShift(_response);
        });
    }

    protected processShift(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SoldClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    goods(body: SoldGoodsDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/sold_goods";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGoods(_response);
        });
    }

    protected processGoods(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    statistics(id: number, day: Date , cancelToken?: CancelToken | undefined): Promise<ReducedSnapshotDto[]> {
        let url_ = this.baseUrl + "/sold_statistics/{id}/{day}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (day === undefined || day === null)
            throw new Error("The parameter 'day' must be defined.");
        url_ = url_.replace("{day}", encodeURIComponent(day ? "" + day.toJSON() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatistics(_response);
        });
    }

    protected processStatistics(response: AxiosResponse): Promise<ReducedSnapshotDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReducedSnapshotDto.fromJS(item));
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReducedSnapshotDto[]>(<any>null);
    }
}

export class UpdateClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    token( token?:string | undefined, cancelToken?: CancelToken | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/update_token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain",
                Authorization: `Bearer ${token}`,
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToken(_response);
        });
    }

    protected processToken(response: AxiosResponse): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }
}

export class AddClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    user(body: AddUserDto | undefined , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/add_user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: AxiosResponse): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        result401![key] = resultData401[key];
                }
            }
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }
}

export class RemoveClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    user(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/remove_user?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain",
                "Access-Control-Allow-Origin": "*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUser(_response);
        });
    }

    protected processUser(response: AxiosResponse): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return result200;
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        result400![key] = resultData400[key];
                }
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }
}

export class AddUserDto implements IAddUserDto {
    id!: number;
    name!: string;
    surname!: string;
    date!: Date;

    constructor(data?: IAddUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AddUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAddUserDto {
    id: number;
    name: string;
    surname: string;
    date: Date;
}

export class EditGoodsListDto implements IEditGoodsListDto {
    user_id!: number;
    id?: string | undefined;
    new!: boolean;
    remove!: boolean;
    restore!: boolean;
    name?: string | undefined;
    category?: string | undefined;
    store?: number;
    r_price?: number;
    w_price?: number;

    constructor(data?: IEditGoodsListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user_id = _data["user_id"];
            this.id = _data["id"];
            this.new = _data["new"];
            this.remove = _data["remove"];
            this.restore = _data["restore"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.store = _data["store"];
            this.r_price = _data["r_price"];
            this.w_price = _data["w_price"];
        }
    }

    static fromJS(data: any): EditGoodsListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditGoodsListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id;
        data["id"] = this.id;
        data["new"] = this.new;
        data["remove"] = this.remove;
        data["restore"] = this.restore;
        data["name"] = this.name;
        data["category"] = this.category;
        data["store"] = this.store;
        data["r_price"] = this.r_price;
        data["w_price"] = this.w_price;
        return data; 
    }
}

export interface IEditGoodsListDto {
    user_id: number;
    id?: string | undefined;
    new: boolean;
    remove: boolean;
    restore: boolean;
    name?: string | undefined;
    category?: string | undefined;
    store?: number;
    r_price?: number;
    w_price?: number;
}

export class GoodsItemDto implements IGoodsItemDto {
    id!: string;
    name!: string;
    category!: string;
    price!: number;
    active!: boolean;

    constructor(data?: IGoodsItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.price = _data["price"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): GoodsItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["category"] = this.category;
        data["price"] = this.price;
        data["active"] = this.active;
        return data; 
    }
}

export interface IGoodsItemDto {
    id: string;
    name: string;
    category: string;
    price: number;
    active: boolean;
}

export class GoodsItemSupplyDto implements IGoodsItemSupplyDto {
    id!: string;
    receipt!: number;
    price!: number;

    constructor(data?: IGoodsItemSupplyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receipt = _data["receipt"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): GoodsItemSupplyDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsItemSupplyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receipt"] = this.receipt;
        data["price"] = this.price;
        return data; 
    }
}

export interface IGoodsItemSupplyDto {
    id: string;
    receipt: number;
    price: number;
}

export class GoodsRevisionDto implements IGoodsRevisionDto {
    id!: number;
    items!: RevisionGoodsItemDto[];

    constructor(data?: IGoodsRevisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RevisionGoodsItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GoodsRevisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsRevisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGoodsRevisionDto {
    id: number;
    items: RevisionGoodsItemDto[];
}

export class GoodsSuppliesDto implements IGoodsSuppliesDto {
    id!: number;
    items!: GoodsItemSupplyDto[];

    constructor(data?: IGoodsSuppliesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GoodsItemSupplyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GoodsSuppliesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsSuppliesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGoodsSuppliesDto {
    id: number;
    items: GoodsItemSupplyDto[];
}

export class ReducedItemInfoDto implements IReducedItemInfoDto {
    name!: string;
    category!: string;
    id!: string;
    sold!: number;
    price!: number;

    constructor(data?: IReducedItemInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
            this.id = _data["id"];
            this.sold = _data["sold"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ReducedItemInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReducedItemInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        data["id"] = this.id;
        data["sold"] = this.sold;
        data["price"] = this.price;
        return data; 
    }
}

export interface IReducedItemInfoDto {
    name: string;
    category: string;
    id: string;
    sold: number;
    price: number;
}

export class ReducedSnapshotDto implements IReducedSnapshotDto {
    name!: string;
    cash!: number;
    snapshots!: ReducedItemInfoDto[];

    constructor(data?: IReducedSnapshotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.snapshots = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.cash = _data["cash"];
            if (Array.isArray(_data["snapshots"])) {
                this.snapshots = [] as any;
                for (let item of _data["snapshots"])
                    this.snapshots!.push(ReducedItemInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReducedSnapshotDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReducedSnapshotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["cash"] = this.cash;
        if (Array.isArray(this.snapshots)) {
            data["snapshots"] = [];
            for (let item of this.snapshots)
                data["snapshots"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReducedSnapshotDto {
    name: string;
    cash: number;
    snapshots: ReducedItemInfoDto[];
}

export class RevisionGoodsItemDto implements IRevisionGoodsItemDto {
    id!: string;
    name!: string;
    category!: string;
    storage!: number;
    price!: number;
    write_off!: number;

    constructor(data?: IRevisionGoodsItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.storage = _data["storage"];
            this.price = _data["price"];
            this.write_off = _data["write_off"];
        }
    }

    static fromJS(data: any): RevisionGoodsItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevisionGoodsItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["category"] = this.category;
        data["storage"] = this.storage;
        data["price"] = this.price;
        data["write_off"] = this.write_off;
        return data; 
    }
}

export interface IRevisionGoodsItemDto {
    id: string;
    name: string;
    category: string;
    storage: number;
    price: number;
    write_off: number;
}

export class ShiftSnapshotDto implements IShiftSnapshotDto {
    name!: string;
    cash!: number;
    snapshots!: StorageItemInfoDto[];

    constructor(data?: IShiftSnapshotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.snapshots = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.cash = _data["cash"];
            if (Array.isArray(_data["snapshots"])) {
                this.snapshots = [] as any;
                for (let item of _data["snapshots"])
                    this.snapshots!.push(StorageItemInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShiftSnapshotDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShiftSnapshotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["cash"] = this.cash;
        if (Array.isArray(this.snapshots)) {
            data["snapshots"] = [];
            for (let item of this.snapshots)
                data["snapshots"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShiftSnapshotDto {
    name: string;
    cash: number;
    snapshots: StorageItemInfoDto[];
}

export class SignInDto implements ISignInDto {
    login!: string;
    password!: string;

    constructor(data?: ISignInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignInDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["password"] = this.password;
        return data; 
    }
}

export interface ISignInDto {
    login: string;
    password: string;
}

export class SoldGoodsDto implements ISoldGoodsDto {
    id!: number;
    sold!: { [key: string]: number; };

    constructor(data?: ISoldGoodsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sold = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["sold"]) {
                this.sold = {} as any;
                for (let key in _data["sold"]) {
                    if (_data["sold"].hasOwnProperty(key))
                        this.sold![key] = _data["sold"][key];
                }
            }
        }
    }

    static fromJS(data: any): SoldGoodsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoldGoodsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.sold) {
            data["sold"] = {};
            for (let key in this.sold) {
                if (this.sold.hasOwnProperty(key))
                    data["sold"][key] = this.sold[key];
            }
        }
        return data; 
    }
}

export interface ISoldGoodsDto {
    id: number;
    sold: { [key: string]: number; };
}

export class StorageItemInfoDto implements IStorageItemInfoDto {
    name!: string;
    category!: string;
    id!: string;
    write_off!: number;
    receipt!: number;
    storage!: number;
    sold!: number;
    r_price!: number;
    w_price!: number;
    readonly income!: number;
    readonly wsp_spending!: number;
    readonly wow_los!: number;
    readonly wor_los!: number;

    constructor(data?: IStorageItemInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.category = _data["category"];
            this.id = _data["id"];
            this.write_off = _data["write_off"];
            this.receipt = _data["receipt"];
            this.storage = _data["storage"];
            this.sold = _data["sold"];
            this.r_price = _data["r_price"];
            this.w_price = _data["w_price"];
            (<any>this).income = _data["income"];
            (<any>this).wsp_spending = _data["wsp_spending"];
            (<any>this).wow_los = _data["wow_los"];
            (<any>this).wor_los = _data["wor_los"];
        }
    }

    static fromJS(data: any): StorageItemInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new StorageItemInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["category"] = this.category;
        data["id"] = this.id;
        data["write_off"] = this.write_off;
        data["receipt"] = this.receipt;
        data["storage"] = this.storage;
        data["sold"] = this.sold;
        data["r_price"] = this.r_price;
        data["w_price"] = this.w_price;
        data["income"] = this.income;
        data["wsp_spending"] = this.wsp_spending;
        data["wow_los"] = this.wow_los;
        data["wor_los"] = this.wor_los;
        return data; 
    }
}

export interface IStorageItemInfoDto {
    name: string;
    category: string;
    id: string;
    write_off: number;
    receipt: number;
    storage: number;
    sold: number;
    r_price: number;
    w_price: number;
    income: number;
    wsp_spending: number;
    wow_los: number;
    wor_los: number;
}

export class UserInfoDto implements IUserInfoDto {
    id!: number;
    is_admin!: boolean;
    shift_opened!: boolean;
    name!: string;
    token!: string;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.is_admin = _data["is_admin"];
            this.shift_opened = _data["shift_opened"];
            this.name = _data["name"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["is_admin"] = this.is_admin;
        data["shift_opened"] = this.shift_opened;
        data["name"] = this.name;
        data["token"] = this.token;
        return data; 
    }
}

export interface IUserInfoDto {
    id: number;
    is_admin: boolean;
    shift_opened: boolean;
    name: string;
    token: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}